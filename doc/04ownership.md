# 所有权系统

## 通用概念

### 值类型`Value`

**值类型是指数据直接存储在栈中的数据类型**,一些原生类型，比如数值、布尔值、结构体等都是值类型。对值类型的操作效率比较高，使用完立即会被回收。值类型作为**右值**(在值表达式中)执行赋值操作时，会自动复制一个新的值副本。

### 引用类型`Reference`

**引用类型将数据存储在堆中**，而栈中只存放指向堆中数据的地址`指针`，比如数组、字符串等。因此对引用类型的操作效率一般比较低，使用完交给`GC`回收，没有`GC`的语言则需要靠手工来回收。

### 区别

- 值语义`Value Semantic`: 按位复制以后，与原始对象无关。
- 引用语义`Reference Semantic`: 也叫指针语义。一般是指将数据存储于堆内存中，通过栈内存的指针来管理堆内存的数据，并且引用语义禁止按位复制。

按位复制就是指栈复制，也叫浅复制，它只复制栈上的数据。相对而言，深复制就是对栈上和堆上的数据一起复制。

值语义可以保证变量值的独立性`Independence`。如果想修改某个变量，只能通过它本身来修改;而如果修改了它本身，并不影响其复制品。而引用语义则是禁止按位复制的，因为按位复制只能复制栈上的指针，堆上的数据就多
了一个管理者，多了一层内存安全的隐患.引用语义类型不能实现`Copy`，可以实现`Clone`的`clone`方法，以实现深复制，在需要的时候可以显式调用。

## 所有权机制

对于可以安全地在栈上进行按位复制的类型，就只需要按位复制，也方便管理内存。对于在堆上存储的数据，因为无法安全地在栈上进行按位复制，如果要保证内存安全，就必须进行深度复制。深度复制需要在堆内存中重新开辟空间，这会带来更多的性能开销。如果堆
上的数据不变，只需要在栈上移动指向堆内存的指针地址，不仅保证了内存安全，还可以拥有与栈复制同样的性能。

**一个值的所有权被转移给另外一个变量绑定的过程，就叫作所有权转移。**

Rust中每个值都有一个所有者，更进一步说就是，Rust 中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者。

### 所有权的特点

- 控制资源(不仅仅是内存)的释放。
- 出借所有权，包括不可变(共享)的和可变(独占)的。
- 转移所有权。

## 绑定,作用域和生命周期

可变状态绝不能共享，否则会增加函数之间的祸合度，函数中的变量状态在任何时候发生改变都将 变得难以控制，从而让函数产生"副作用"。可变状态也更不利于多线程并发程序，容易引发数据竞争。

### 绑定

变量绑定具有"时空"双重属性。

- 空间属性是指标识符与内存空间进行了绑定。
- 时间属性是指绑定的时效性，也就是指它的生存周期。

### 闭包作用域

闭包会创建新的作用域，对于环境变量来说有以下三种捕获方式：

- 对于复制语义类型，以不可变引用`(&T)`来捕获。
- 对于移动语义类型， 执行移动语义`(move)`转移所有权来捕获。
- 对于可变绑定，如果在闭包中包含对其进行修改的操作，则以可变引用`(&mut)`来捕获。

## 所有权借用

### 引用与借用

引用`Reference`是Rust提供的一种指针语义。引用是基于指针的实现，指针的区别是，指针保存的是其指向内存的地址，引用可以看作某块内存的别名`Alias`，需要满足编译器的各种安全检查规则。引用也分为不可变引用和可变引用。使用`&`
符号进行不可变引用，使用`&mut` 符号进行可变引用。

在所有权系统中，引用`&x`也可称为x的借用`Borrowing`， 通过`&`操作符来完成所有权租借。既然是借用所有权，那么引用并不会造成绑定变量所有权的转移。但是借用所有权会 让所有者`owner`受到如下限制

- 在不可变借用期间，所有者不能修改资源，并且也不能再进行可变借用。 ·
- 在可变借用期间，所有者不能访问资源，并且也不能再出借所有权。
- 引用在离开作用域之时，就是其归还所有权之时。使用借用与直接使用拥有所有权的值一样自然，而且还不需要转移所有权。

### 借用规则

为了保证内存安全，借用必须遵循以下三个规则。

- 规则一：借用的生命周期不能长于出借方(拥有所有权的对象)的生命周期。
- 规则二：可变借用(引用)不能有别名(Alias)，因为可变借用具有独占性。
- 规则三：不可变借用(引用)不能再次出借为可变借用。

规则一是为了防止出现悬垂指针。规则二和三可以总结为一条核心的原则：共享不可变，可变不共享。Rust 编译器会做严格的借用检查，违反以上规则的行为均无法正常通过编译。

**解引用操作会获得所有权**

## 生命周期参数

### 显式生命周期参数

生命周期参数必须以单引号开头，参数名通常都是小写字母，比如`'a` 。生命周期参数位于引用符号`&`后面，并使用空格来分割生命周期参数和类型,标注生命周期参数并不能改变任何引用的生命周期长短，它只用于编译器的借用检查，来防止悬垂指针。

#### 函数签名中的生命周期参数

```rust
fn foo<'a>(s: &'a str, t: &'a str) -> &'a str;
```

函数名后面的`<'a>`为生命周期参数的声明，与泛型参数类似，必须先声明才能使用。函数或方法参数的生命周期叫作输入生命周期`input lifetime`，而返回值的生命周期被称为输出生命周期`output lifetime`。
函数签名的生命周期参数有这样的限制条件:输出(借用方)的生命周期长度必须不长于输入(出借方)的生命周期长度(此条件依然遵循借用规则一).**禁止在没有任何输入参数的情况下返回引用**

**从函数中返回(输出)一个引用，其生命周期参数必须与函数的参数(输入)相匹配，否则标注生命周期参数也毫无意义**

## 智能指针与所有权

## 并发安全与所有权

## 非词法作用域生命周期