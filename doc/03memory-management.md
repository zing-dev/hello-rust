# 内存管理

**虚拟内存是一种对物理存储设备的统一抽象**，物理存储设备包括物理内存、磁盘、寄存器、高速缓存等。好处方便同时运行多道程序，使得每个进程都有各自独立的进程地址空间，并且可以通过操作系统调度将外存当作内存来使用

虚拟地址空间是线性空间，用户所接触到的地址都是虚拟地址，而不是真实的物理地址。利用这种虚拟地址不但能保护操作系统，让进程在各自的地址空间内操作内存,用户程序可以使用比物理内存更大的地址空间

- 用户空间
- 内核空间

它们的比例是3:1 (Linux)或2:2(Windows)以Linux 系统 为例，32位计算机的地址空间大小是4GB，寻址范围是`0x00000000-0xFFFFFFFF`。然后通
**内存分页等底层复杂的机制来把虚拟地址翻译为物理地址**

栈向下(由高地址向低地址)增长，堆向上(由低地址向高地址)增长

## 栈 `stack`

限定了插入和删除数据只能在线性表固定的一端进行,操作栈的一端被称为栈顶，相反的一端被称为栈底。从栈顶压入数据叫入栈(push)，从栈顶弹出数据叫出栈(pop), 后进先出(`LIFO,Last in First Out`)线性表

**栈内存最重要的作用是在程序运行过程中保存函数调用所要维护的信息**存储每次函数调用所需信息的记录单元被称为`栈帧`(`Stack Frame`)，也被称为活动记录(`Activate Record` )

### 栈帧

- 函数的返回地址和参数
- 临时变量。包括函数内部的非静态局部变量和编译器产生的临时变量
- 保存的上下文

`EBP`指针是帧指针`Frame Pointer`，它指向当前栈帧的一个固定的位置，而`ESP`始终指向栈顶。`EBP`指向的值是调用该函数之前的旧的`EBP`值，在函数返回时，通过该值恢复到调用前的值。由`EBP`指针和`ESP`
指针构成的区域就是一个栈帧， 一般指当前栈帧。 栈帧的分配非常快，其中的局部变量都是预分配内存，在栈上分配的值都是可以预先确定大小的类型。当函数结束调用的时候，栈帧会被自动释放，栈上数据的生命周期是 在一个函数调用周期内的。

## 堆 `heap`

栈内存中保存的数据，生命周期都比较短，会随着函数调用的完成而消亡。但很多情况下会需要能相对长久地保存在内存中的数据，以便跨函数使用，这就是堆内存发挥作用的地方。堆内存是一块巨大的内存空间，占了虚拟内存空间的绝大部分。程序不可以主动申请栈
内存，但可以主动申请堆内存。在堆内存中存放的数据会在程序运行过程中一直存在，除非该内存被主动释放掉。

**堆是一大块内存空间，程序通过malloc申请到的内存空间是大小不一、不连续且无序的**

### 空闲链表 `Free List`

把堆中空闲的内存地址记录为链表，当系统收到程序申请时，会遍历该链表：当找到适合的空间堆节点时，会将此节点从链表中删除；当空间被回收以后，再将其加到空闲链表中。空闲链表的优势是实现简单，但如果链表遭到破坏，整个堆就无法正常工作。

### 位图标记 `Bitmap`

将整个堆划分为大量大小相等的块。当程序申请内存时，总是分配整数个块的空间。每块内存都用一个二进制位来表示其状态，如果该内存被占用，则相应位图中的位置置为1,如果该内存空闲，则相应位图中的位置置为0。位图的优势是速度快，如
果单个内存块数据遭到破坏，也不会影响整个堆，但缺点是容易产生内存碎片

## 内存布局

内存中数据的排列方式

CPU在单位时间内能处理的一组二进制数称为`字`， 这组二进制数的位数称为`字长`。如果是32位CPU，其字长为32位，也就是4个字节。一般来说，字长越大，计算机处理信息的速度就越快

内存对齐包括基本数据对齐和结构体(或联合体)数据对齐。对于基本数据类型，默认对齐方式是按其大小进行对齐，也被称作自然对齐。比如Rust中u32类型占4字节，则它默认对齐方式为4 字节对齐。

假设对齐字节数为N (N= 1, 2, 4, 8, 1 6)，每个成员内存长度为`Len`, `Max(Len)`为最大成员内存长度。如果没有外部明确的规定，`N`默认按`Max(Len)`对齐。字节对齐规则为

- 结构体的起始地址能够被Max(Len)整除。
- 结构体中每个成员相对于结构体起始地址的偏移量，即对齐值，应该是Min(N,Len)的倍数，若不满足对齐值的要求，编译器会在成员之间填充若干个字节。
- 结构体的总长度应该是`Min(N,Max(Len))的倍数，若不满足总长度要求，则编译器会 在为最后一个成员分配空间后，在其后面填充若干个字节。

## 变量与函数

- 全局变量
    - 常量变量
    - 静态变量
- 局部变量

### 常量变量

常量使用`const`关键字定义，并且需要显式指明类型，只能进行简单赋值，只能使用支持`CTFE`的表达式。常量没有固定的内存地址，因为其生命周期是全局的，随着程序消亡而消亡，并且会被编译器有效地内联到每个使用到它的地方。

### 静态变量

静态变量使用`static`关键字定义，跟常量一样需要显式指明类型，进行简单赋值，而不能使用任何表达式。静态变量的生命周期也是全局的，但它并不会被内联，每个静态变量都有一个固定的内存地址。

静态变量并非被分配到栈中，也不是在堆中，而是和程序代码一起被存储于静态存储区中。静态存储区是伴随着程序的二进制文件的生成(编译时)被分配的，并且在程序的整个运行期都会存在。Rust中的字街串字面量同样是存储于静态内存中的。

**在函数中定义的局部变量都会被默认存储到栈中**

## 智能指针与`RAII`

Rust中的指针大致可以分为三种： `引用`、`原生指针（裸指针）`和`智能指针`。 引用就是Rust提供的普通指针，用`&`和`& mut`操作符来创建，形如`&T`和`&mut T`。原生指针是指形如`*const T`
和`*mut T`这样的类型。 引用和原生指针类型之间的异同如下。

- 可以通过`as`操作符随意转换，例如`&T as *const T`和`&mut T as *mut T`
- 原生指针可以在`unsafe`块下任意使用，不受Rust的安全检查规则的限制，而引用则必须受到编译器安全检查规则的限制。

### 智能指针

智能指针`smart pointer`实际上是一种结构体，只不过它的行为类似指针。智能指针是对指针的一层封装，提供了一些额外的功能，比如自动释放堆内存。智能指针区别于常规结构体的特性在于，它实现了`Deref`和`Drop`
这两个`trait` 。`Deref`提供了解引用能力， `Drop` 提供了自动析构的能力，正是这两个`trait`让智能指针拥有了类似指针的行为。

### 资源获取及初始化 `RAII` `Resource Acquisition ls Initialization`

`RAII`的机制是使用构造函数来初始化资源，使用析构函数来回收资源看上去`RAII`所要做的事确实跟GC差不多。但`RAII`和`GC`最大的不同在于，`RAII`
将资源托管给创建堆内存的指针对象本身来管理，并保证资源在其生命周期内始终有效，一旦生命周期终止，资源马上会被回收