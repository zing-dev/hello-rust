## 基本构成

- 语言规范
- 编译器
- 核心库
- 标准库
- 包管理器

### 语言规范

- 对每种语言结构及其用法的描述
- 对内存模型,并发模型,链接,调试等内存的描述
- 影响语言设计的基本原理和参考

### 编译器`rustc`

- 跨平台
- 交叉编译
- LLVM
- Rust开发
- 词法分析静态类型检查
- 调试友好

### 核心库

`#[no_std]`引入核心库

- 基本的trait
- 基本的原始数据类型
- 功能型数据类型
- 宏定义

### 标准库

- 核心库
- 并非,IO和运行时
- 平台抽象
- 底层操作接口,操作内存,指针,调用编译器固有函数
- 可选和错误处理类型`Option`和`Result`

### 包管理器`crate`

- 包源代码网站 `crates.io`
- 文档网站 `docs.rs`

## 语句`Statement`与表达式`Expression`

### 声明语句(Declaration statement)

声明各种语言项,声明变量,静态变量,常量,结构体,函数

### 表达式语句 (Expression statement)

特指以分号结尾的表达式

## 变量与绑定

`let`关键字创建变量称为绑定,表明标识符和值之间建立的一种关联关系

### 位置表达式 左值 (表示内存位置的表达式)

- 本地变量
- 静态变量
- 解引用`(*expr)`
- 数组索引 `(expr[expr])`
- 字段引用 `(expr.field)`
- 位置表达式组合

### 值表达式 右值 (引用某个存储单元地址中的数据)

从语义的角度来说,位置表达式代表了持久性数据,值表达式代表了临时数据

### 位置上下文

- 赋值或者复合赋值语句左侧的操作数
- 一元引用表达式的独立操作数
- 包含隐式借用(引用)的操作数
- `match`判别式或`let`绑定右侧在使用`ref`模式匹配

### 可变绑定与不可变绑定

- 可变绑定 `let mut v`
- 不可变绑定 `let v`

### 所有权与引用

当位置表达式出现在值上下文中时,该位置表达式将会把内存地址转移给另外一个位置 表达式,这其实是所有权的转移

**在语义上,每个变量绑定实际上都拥有该存储单元的所有权,这种转移内存地址的行为就是所有权`OwnerShip`的转移,在Rust中称为移动`Move`语义,那种不转移的情况实际上是一种复制`Copy`语义。**

引用操作符`＆`,可以直接获取表达式的存储单元地址,即内存位置.可以通过该内存位置对存储进行读取。

## 函数与闭包

函数是通过关键字`fn`定义的

### 作用域与生命周期

Rust语言的作用域是静态作用域，即词法作用域（`Lexical Scope`）

用`let`定义同名变量的做法叫变量遮蔽(`Variable Shadow`)

### `CTFE`机制 编译时函数执行`Compile-Time Function Execution`

Rust 中的`CTFE`是由`miri`来执行的。`mir`是一个`MIR`解释器，目前己经被集成到了Rust 编译器rustc中。Rust编译器目前可以支持的常量表达式有： 字面量、元组、数组、字段结
构体、枚举、只包含单行代码的块表达式、范围等

### 闭包(匿名函数)

- 可以像函数一样被调用。
- 可以捕获上下文环境中的自由变量。
- 可以自动推断输入和返回的类型。

闭包可以捕获外部变量，而函数不可以

Rust中闭包实际上就是由一个`匿名结构体`和`trait`来组合实现的。

### `match`表达式与模式匹配

模式匹配用于判断类型或值是否存在可以匹配的模
[match example](https://note.youdao.com/s/DyN9O77L)

```rust
#[test]
fn quick_start() {
    let number = 42;
    match number {
        0 => println!("0"),
        1...3 => println!("1...3"),
        5 | 7 | 13 => println!("5|7|13"),
        n @ 42 => println!("n:{}", n),
        _ => println!("default"),
    }
}
```

## 基本数据类型

### 布尔类型

- true
- false

### 基本数字类型

#### 固定大小的类型

无符号整数`Unsigned Integer`和符号整数`Signed Integer`其中,无符号整数包括：

- u8,范围`0～2^8-1`,占用1字节,用于文件或网络I/O中读取数据流时表示字节序列。
- ul6,范围`0～2^16-1`,占用2字节。
- u32,范围`0～2^32-1`,占用4字节。
- u64,范围`0～2^64-1`,占用8个字节。
- ul28,范围`0～2^128-1`,占用16个字节。

符号整数包括：

- i8,范围`-2^7～2^7-1`,占用1个字节。
- i16,范围`-2^15~2^15-1`,占用2个字节。
- i32,范围`-2^31～2^31-1`,占用4个字节。
- i64,范围`-2^63～2^63-1`,占用8个字节。
- i128,范围`-2^127~2^127-1`,占用16个字节。

### 动态大小类型

- usize,数值范围为`0～2^32-1`或`0~2^64-1`,占用4个或8个字节。
- isize,数值范围为`-2^31～2^31-1`或`-2^63~2^63-1`,占用4个或8个字节。

### 浮点数类型

- f32,单精度32位浮点数,至少6位有效数字,数值范围为`-3.4*10^38~3.4*10^38`
- f64,单精度64位浮点数,至少15位有效数字,数值范围为`-1.8*10^308~1.8*10^308`

### 字符类型

- 单引号来定义字符`Char`类型。字符类型代表的是一个`Unicode`标量值，每个字符占4个字节

### 数组类型

数组的类型签名为`[T;N]`,`T`是一个泛型标记,`N`代表数组的长度,是一个编译时常量,必须在编译时确定其值.

- 数组大小固定。
- 元素均为同类型。
- 默认不可变。

### 范围类型

包括左闭右开和全闭两种区间

### 切片类型

切片`Slice`类型是对一个数组(包括固定大小数组和动态数组)的引用片段,有利于安全有效地访问数组的一部分,而不需要拷贝.因为理论上讲,切片引用的是已经存在的变量.在底层,切片代表一个指向数组起始位置的指针和数组长度.用`[T]`
类型表示连续序列,那么切片类型就是`＆[T]`和`＆mut[T]`

**使用`vec!`宏定义的动态数组,也可以通过引用操作符来得到一个切片**

### `str`字符串类型

**Rust提供了原始的字符串类型`str`,也叫字符串切片.通常以不可变借用的形式存在，即`＆str`,出于内存安全的考虑，Rust将字符串分为两种类型,一种是固定长度字符串,不可随便更改长度,就是`str`
字符串：另一种是可增长字符串,可以随意改变长度,就是`String`
字符串**

`str`字符串类型由两部分组成：**指向字符串序列的指针和记录长度的值**,可以通过`str`模块提供的`as_ptr`和`len`方法分别求得指针和长度

Rust中的字符串本质上是一段**有效的UTF8字节序列**

### 原生指针

将表示内存地址的类型称为指针

- 引用`Reference`
- 原生指针`Raw Pointer`
- 函数指针`fn Pointer`
- 智能指针`Smart Pointer`

**引用**本质上是一种非空指针。Rust可以划分为`Safe Rust`和`Unsafe Rust`两部,引用主要应用于`Safe Rust`中.在`Safe Rust`中,编译器会对引用进行借用检查,保证内存安全和类型安全。

**原生指针**主要用于`Unsafe Rust`中.直接使用原生指针是不安全的,比如原生指针可能指向一个Null或者一个己经被释放的内存区域，因为使用原生指针的地方不在`Safe Rust`
的可控范围内，所以需要程序员自己保证安全.Rust支持两种原生指针：不可变原生指针`*const T`和可变原生指针`*mut T`.

### `never`类型

`never`类型，即`！`该类型用于表示永远不可能有返回值的计算类型，比如线程退出的时候， 就不可能有返回值

## 复合数据类型

- 元组`Tuple`
- 结构体`Struct`
- 枚举体`Enum`
- 联合体`Union`

### 元组

元组`Tuple`是一种异构有限序列,形如`(T,U,M,N)`.所谓异构,就是指元组内的元素可以是不同类型,所谓有限，是指元组有固定的长度

### 结构体

- 具名结构体`Named-Field Struct`
- 元组结构体`Tuple-Like Struct` 元组和具名结构体的混合体,字段没有名称，只有类型
- 单元结构体`Unit-Like Struct` 没有任何字段的结构体

### 枚举

枚举体`Enum` 也可称为枚举类型或枚举,该类型包含了全部可能的情况,有效地防止用户提供无效值。枚举类型可以使用`enum`关键字来定义

## 常用集合类型

### 线性序列：向量

向量也是一种数组,和基本数据类型中的数组的区别在于,向量可动态增长.

`vec!`是一个宏,用来创建向量字面量。宏语句可以使用圆括号,也可以使用中括号和花括号,一般使用中括号来表示数组.

### 线性序列：双端队列

双端队列`Double-ended Queue`,缩写为`Deque`是一种同时具有`队列先进先出`和`栈后进先出`性质的数据结构。双端队列中的元素可以从两端弹出，插入和删除操作被限定在队列的两端进行。

### 线性序列：链表

Rust提供的链表是双向链表,允许在任意一端插入或弹出元素。但是通常最好使用`Vec`或`VecDeque`类型,因为它们比链表更加快速,内存访问效率更高,并且可以更好地利用CPU缓存。

### 智能指针`Smart Pointer`

Rust中的**值默认被分配到栈内存**.可以通过`Box<T>`将值装箱(在堆内存中分配).**`Box<T>`是指向类型为T的堆内存分配值的智能指针**.当`Box<T>`
超出作用域范围时,将调用其析构函数,销毁内部对象,并自动释放堆中的内存.可以通过解引用操作符来获取`Box<T>`
中的T.看得出来,`Box<T>`的行为像引用，并且可以自动释放内存,所以我们称其为智能指针.

### 泛型与`trait`

通常使用字母`T`来代表一个泛型.也就是说这个`Option<T>`枚举类型对于任何类型都适用

**`trait`是Rust实现零成本抽象的基石**,`trait`是对类型行为的抽象

- `trait`是Rust唯一的接口抽象方式。
- 可以静态生成,也可以动态调用。
- 可以当作标记类型拥有某些特定行为的`标签`来使用。

```rust
 mod quick_start {
    struct Duck;

    struct Pig;

    trait Fly {
        fn fly(&self) -> bool;
    }

    impl Fly for Pig {
        fn fly(&self) -> bool {
            false
        }
    }

    impl Fly for Duck {
        fn fly(&self) -> bool {
            true
        }
    }

    // 静态分发
    // Rust 编译器会为fly_static::<Pig>(pig)和fly_static::<Duck>(duck)这两个具体类型的调用生成特殊化的代码
    fn fly_static<T: Fly>(s: T) -> bool {
        s.fly()
    }

    // 动态分发
    // 它会在运行时查找相应类型的方法,会带来一定的运行时开销,不过这种开销很小
    fn fly_dyn(s: &dyn Fly) -> bool {
        s.fly()
    }

    #[test]
    fn test() {
        let pig = Pig;
        assert_eq!(fly_static::<Pig>(pig), false);
        let duck = Duck;
        assert_eq!(fly_static::<Duck>(duck), true);
        assert_eq!(fly_dyn(&Pig), false);
        assert_eq!(fly_dyn(&Duck), true);
    }
}
```

### 错误处理

Rust中的错误处理是通过返回`Result<T,E>`类型的方式进行的,`Result<T,E>`类型是`Option<T>`类型的升级版本，同样定义于标准库中

`Option<T>`类型表示值存在的可能性,`Result<T,E>`类型表示错误的可能性,其中泛型`E`代表`Error`

### 表达式优先级

|  操作符或表达式相关性   | 相关性  |
|  ----  | ----  |
| 路径`Path` |  |
| 方法调用`MethodCall`  |  |
| 字段表达式`FieldExpression`| 从左到右 |
| 函数调用,数组索引 |  |
| 问号操作符`?` |  |
| 一元操作符`-,*,!,&,&mut` |  |
| `as` |  |
| 二元计算`*,/,%` | 从左到右 |
| 二元计算`+,-` | 从左到右 |
| 位移运算`<<,>>` | 从左到右 |
| 位操作`&` | 从左到右 |
| 位操作`^` | 从左到右 |
| 位操作 `│` | 从左到右 |
| 比较操作`==,!=,<,>,<=,>=` | 需要括号 |
| 逻辑与`&&` | 从左到右 |
| 逻辑或`││` | 从左到右 |
| 范围`.. ..=` | 需要括号 |
| 赋值操作`=, +=, -=, *=, /=,%=, &=, ^= |=, <<=, >>= ` | 需要括号 |
| return break 闭包 |  |

### 注释与打印

Rust的文档哲学: 代码即文档,文档即代码

- `//` 对整行注释
- `/* ... */` 对区块注释
- `///` 生成库文档,函数或结构体说明,说明文档的上方
- `//!` 生成库文档,整个模块的功能,模块文件头部